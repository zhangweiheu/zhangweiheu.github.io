<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[摆渡人]]></title>
      <url>http://blog.zhangweiheu.cn/2016/06/02/%E6%91%86%E6%B8%A1%E4%BA%BA/</url>
      <content type="html"><![CDATA[<h4 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h4><blockquote>
<p>　　摆渡人这本书，故事不长，情节也没有什么跌宕起伏，平淡之中隐藏的是随时死亡的风险。<br>　　博主也是刚读一遍，没什么特别深的见解，感觉这本书主要还是讲了一场结局完美的爱情之旅。爱情可以改变两个人，可以让他们在前途未卜的状况下，为了对方付出自己的性命，难道说这就是“问世间情为何物？直教人生死相许”？  　　　　　　　　　　博主目前也就这点感想，欢迎大家推荐好书、好剧……</p>
</blockquote>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSH权限]]></title>
      <url>http://blog.zhangweiheu.cn/2016/05/28/SSH%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<h4 id="ssh权限"><a href="#ssh权限" class="headerlink" title="ssh权限"></a>ssh权限</h4><p>　今天Win机器换了密钥对，所以要更新机器上的公钥，在给自己新增加的用户添加完密钥以后，Xshell登陆时发现使用新的密钥登陆不上去，提示密钥未在远程主机上注册，在google以后发现是文件夹和authorized_keys的权限问题。　</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[岛上书店]]></title>
      <url>http://blog.zhangweiheu.cn/2016/05/28/%E5%B2%9B%E4%B8%8A%E4%B9%A6%E5%BA%97/</url>
      <content type="html"><![CDATA[<h4 id="个人对文中细节的理解"><a href="#个人对文中细节的理解" class="headerlink" title="个人对文中细节的理解"></a>个人对文中细节的理解</h4><ul>
<li><p>A.J是一个黑人，这点文中写的很少，大概也就两句话，从这点看出，美国社会对黑人还是很歧视的，在妮可死后，书店的销售额少了很多，而且大家对待A.J的态度也符合当时白人对一个黑人鳏夫的态度。</p>
</li>
<li><p>个人认为A.J是知道丹尼尔是玛雅的父亲的，从小岛的环境看，到玛利安带着孩子一个人来到这个很难到达的小岛，不合情理，而且还在丢下孩子以后—自杀，显然是为了寻找某个人，再者从A.J对整个小岛的了解，加上丹尼尔是哈维死后唯一一个挚友，而且丹尼尔有很多情人，再者丹尼尔对玛雅的照顾，以及最后A.J对玛雅的遗言：爱。所以可以分析出A.J是知道玛雅身世，而且出于喜欢孩子，就收养了玛雅。</p>
</li>
<li><p>关于遗言，我的理解是A.J想让玛雅在知道自己的身世以后，原谅自己的父母，原谅所有人，让玛雅活的更幸福一点，忘记不愉快的出身。</p>
</li>
<li><p>人无完人，只有遇到对的人，才会真正得到幸福，而对的人也只是在对的时间出现。如果不是玛雅生病，A.J不会看《迟暮花开》，也不会和阿米莉娅有深入的交流，也不会成为soulmate。这点在整本书中，都有很多的体现，可见遇到对的那个人是多么难，但是遇到就是一辈子的幸福。 </p>
</li>
<li><p>这本书通篇可以理解为以爱为主题：寻爱、示爱、守护爱。 人生不易，对待感情真的要认真，真爱难寻，很难将就，将就是对两个人的折磨。</p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker修改系统时区]]></title>
      <url>http://blog.zhangweiheu.cn/2016/05/08/Docker%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/</url>
      <content type="html"><![CDATA[<h3 id="Ubantu修改系统时区"><a href="#Ubantu修改系统时区" class="headerlink" title="Ubantu修改系统时区"></a>Ubantu修改系统时区</h3><p>直接修改/etc/timezone<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Asia/shanghai&quot; &gt; /etc/timezone</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### Centos修改系统时区  </span><br><span class="line">```shell</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB备份与恢复命令]]></title>
      <url>http://blog.zhangweiheu.cn/2016/05/05/MongoDB%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>先到mongodb/bin/目录下</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>./mongodump –db xxx(数据库名称)  –out /xxx/(备份路径)<br>默认路径在当前路径下：dump/xxx   </p>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>./mongorestore –db xxx(数据库名称) ./xxx(数据库备份路径)</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tar命令]]></title>
      <url>http://blog.zhangweiheu.cn/2016/05/05/tar%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="解压命令"><a href="#解压命令" class="headerlink" title="解压命令"></a>解压命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ./xxx.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf ./xxx.tar.gz xxx</span><br></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p> Cannot open: Permission denied;<br>  没有权限</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim]]></title>
      <url>http://blog.zhangweiheu.cn/2016/04/29/Vim/</url>
      <content type="html"><![CDATA[<h4 id="Ubantu安装软件异常"><a href="#Ubantu安装软件异常" class="headerlink" title="Ubantu安装软件异常"></a>Ubantu安装软件异常</h4><ul>
<li>Unable to locate package vim</li>
<li>Package ‘vim-nox’ has no installation candidate</li>
</ul>
<p>解决方法：apt-get update  </p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jenkins插件]]></title>
      <url>http://blog.zhangweiheu.cn/2016/04/28/Jenkins%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="安装jenkins后“可选插件”列表为空"><a href="#安装jenkins后“可选插件”列表为空" class="headerlink" title="安装jenkins后“可选插件”列表为空"></a>安装jenkins后“可选插件”列表为空</h3><p>因为插件站点被qiang,解决方法：更换插件源<br>选择插件管理-&gt;高级-&gt;升级站点-&gt;更改url为：<a href="http://mirror.xmission.com/jenkins/updates/update-center.json" target="_blank" rel="external">http://mirror.xmission.com/jenkins/updates/update-center.json</a> 点击提交<br>完事</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker]]></title>
      <url>http://blog.zhangweiheu.cn/2016/04/27/Docker/</url>
      <content type="html"><![CDATA[<h2 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h2><h3 id="docker安装-系统必须64位"><a href="#docker安装-系统必须64位" class="headerlink" title="docker安装(系统必须64位)"></a>docker安装(系统必须64位)</h3><ul>
<li>centos7:yun install docker,由于docker国内官方没有站点，比较慢，所以建议使用镜像站，安装docker</li>
</ul>
<h3 id="dockerfile构建新的镜像"><a href="#dockerfile构建新的镜像" class="headerlink" title="dockerfile构建新的镜像"></a>dockerfile构建新的镜像</h3><h5 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h5><p>  RUN：镜像构建时要运行的命令，不同于使用docker run启动容器；<br>  CMD：容器启动时要运行的命令，docker run中的命令会覆盖CMD中的命令；eg:CMD[“bash”,”-1”]<br>  ENTRYPOINT：类似于CMD指令，但是该指令不容易在容器启动时被覆盖，而docker run中的参数会被再次传递给ENTRYPOINT；eg：ENTRYPOINT[“nginx”,”-g”,”daemon off”]<br>  WORKDIR：<br>  ENV：<br>  USER：指定该镜像以什么身份去运行；eg:USER zhangwei:administor<br>  VOLUME：用来向基于镜像的容器添加卷<br>  ADD：复制并解压文件<br>  COPY：只是复制文件<br>  ONBUILD：为镜像添加触发器，<br>  docker 命令 ：docker exec -it containerID/NAME /bin/bash  </p>
<h3 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h3><p>$ sudo docker   # docker命令帮助<br>Usage: docker [OPTIONS] COMMAND [arg…]<br> -H=[unix:///var/run/docker.sock]: tcp://host:port to bind/connect to or unix://path/to/socket to use</p>
<p>A self-sufficient runtime for linux containers.</p>
<p>Commands:<br>    attach    Attach to a running container                 </p>
<pre><code>          # 当前shell下attach连接指定运行镜像  
build     Build an image from a Dockerfile              
          # 通过Dockerfile定制镜像
commit    Create a new image from a container&apos;s changes 
          # 提交当前容器为新的镜像
cp        Copy files/folders from the containers filesystem to the host path  
          # 从容器中拷贝指定文件或者目录到宿主机中  
diff      Inspect changes on a container&apos;s filesystem   
          # 查看docker容器变化  
events    Get real time events from the server          
          # 从docker服务获取容器实时事件
export    Stream the contents of a container as a tar archive     
          # 导出容器的内容流作为一个tar归档文件[对应import]  
history   Show the history of an image    
          # 展示一个镜像形成历史  
images    List images    # 列出系统当前镜像  
import    Create a new filesystem image from the contents of a tarball    
          # 从tar包中的内容创建一个新的文件系统映像[对应export]  
info      Display system-wide information   # 显示系统相关信息    
inspect   Return low-level information on a container    
          # 查看容器详细信息  
kill      Kill a running container                        
          # kill指定docker容器  
load    Load an image from a tar archive               
       # 从一个tar包中加载一个镜像[对应save]   login     Register or Login to the docker registry server   
          # 注册或者登陆一个docker源服务器  
logs      Fetch the logs of a container  
          # 输出当前容器日志信息
port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT  
          # 查看映射端口对应的容器内部源端口  
pause     Pause all processes within a container          
          # 暂停容器  
ps        List containers                               
          # 列出容器列表  
pull      Pull an image or a repository from the docker registry server  
          # 从docker镜像源服务器拉取指定镜像或者库镜像  
push      Push an image or a repository to the docker registry server  
          # 推送指定镜像或者库镜像至docker源服务器  
restart   Restart a running container                   
          # 重启运行的容器    
rm        Remove one or more containers                   
          # 移除一个或者多个容器    
rmi       Remove one or more images                 
          # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或-f强制删除]    
run       Run a command in a new container
          # 在一个新的容器中运行一个命令    
save      Save an image to a tar archive  
          # 保存一个镜像为一个tar包[对应load]  
search    Search for an image in the docker index       
          # 在docker index中搜索镜像  
start     Start a stopped containers                    # 启动容器
stop      Stop a running containers                     # 停止容器
tag       Tag an image into a repository                # 给源中镜像打标签
top       Lookup the running processes of a container   # 查看容器中运行的进程信息
unpause   Unpause a paused container                    # 取消暂停容器
version   Show the docker version information           # 查看docker版本号
wait      Block until a container stops, then print its exit code   
          # 截取容器停止时的退出状态值
</code></pre><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java线程状态知识点]]></title>
      <url>http://blog.zhangweiheu.cn/2016/04/18/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="Thread和Runnable实现线程的异同"><a href="#Thread和Runnable实现线程的异同" class="headerlink" title="Thread和Runnable实现线程的异同"></a>Thread和Runnable实现线程的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>都是多线程实现的方式  </li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li><p>Thread是类，而Runnable是接口；Thread是实现了Runnable接口的类。</p>
</li>
<li><p>Runnable具有更好的扩展性，即多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象的资源。</p>
</li>
</ul>
<h2 id="Thread类包含的start-和Run-方法的区别"><a href="#Thread类包含的start-和Run-方法的区别" class="headerlink" title="Thread类包含的start()和Run()方法的区别"></a>Thread类包含的start()和Run()方法的区别</h2><ul>
<li><p>start()：它的作用是启动一个新的线程，新线程会执行相应的Run()方法；start()不能被重复调用。</p>
</li>
<li><p>run():与普通的成员方法一样，可以被重复调用。单独调用会在当前线程中执行run(),而不会启动新线程。</p>
</li>
</ul>
<h2 id="线程状态sleep-、yield-、wait-区别"><a href="#线程状态sleep-、yield-、wait-区别" class="headerlink" title="线程状态sleep()、yield()、wait()区别"></a>线程状态sleep()、yield()、wait()区别</h2><ul>
<li><p>sleep()会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低优先级的线程一个运行的机会；yield()只会给不小于自己优先级的线程一个运行的机会。</p>
</li>
<li><p>当线程执行sleep()方法后，参数long millis指定睡眠时间，转到阻塞状态；当线程执行yield()方法后进入就绪状态。</p>
</li>
<li><p>sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明异常。</p>
</li>
<li><p>sleep()比yield()方法具有更好的移植性</p>
</li>
<li><p>线程调用自身的sleep()或者其他线程的join()方法，进入阻塞状态，该状态停止当前线程但不释放资源，当sleep()或者join()的线程结束以后进入就绪状态</p>
</li>
<li><p>Object.wait()对象锁，释放资源，notify()唤醒回到wait()前中断现场。</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20150827111349802" alt="线程状态转换"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven本地安装jar文件]]></title>
      <url>http://blog.zhangweiheu.cn/2016/04/17/Maven%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85jar%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h3 id="maven本地仓库安装jar包和源码"><a href="#maven本地仓库安装jar包和源码" class="headerlink" title="maven本地仓库安装jar包和源码"></a>maven本地仓库安装jar包和源码</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:/spymemcached-2.10.3.jar -DgroupId=net.spy -DartifactId=spymemcached -Dversion=2.10.3 -Dpackaging=jar</span><br></pre></td></tr></table></figure>
<h4 id="安装source类的源码"><a href="#安装source类的源码" class="headerlink" title="安装source类的源码"></a>安装source类的源码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:/spymemcached-2.10.3-sources.jar -DgroupId=net.spy -DartifactId=spymemcached -Dversion=2.10.3 -Dpackaging=jar -Dclassifier=sources</span><br></pre></td></tr></table></figure>
<h4 id="安装javadoc类的源码"><a href="#安装javadoc类的源码" class="headerlink" title="安装javadoc类的源码"></a>安装javadoc类的源码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:/spymemcached-2.10.3-javadoc.jar -DgroupId=net.spy -DartifactId=spymemcached -Dversion=2.10.3 -Dpackaging=jar -Dclassifier=javadoc</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实习月度总结]]></title>
      <url>http://blog.zhangweiheu.cn/2015/11/21/%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>　　一个月了，简单写一下这一个月的进步。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul>
<li><p>JIRA和Gitlab可以正常使用的水平，没有什么可说的。</p>
</li>
<li><p>git<br>　　git一个可以用来进行分布式开发的集成工具，用仓库的方式对各个项目代码进行托管和管理。git对于开发者来说是一个非常好的工具，这也是目前开源的分享方式之一。git pull,push,clone,rebase,merge,branch,checkout等基础命令对于新手来说基本足够。深入学习可以阅读《Pro Git》。Sourcetree是一个非常好的图形化工具，一开始都不敢动这些代码，担心出现问题，造成不必要的麻烦，所以每次都非常小心，不过这一周也算是过了这个阶段，自己可以大胆去尝试了。</p>
</li>
<li><p>maven<br>　　对于maven的用法无非是：对项目生命周期的管理、插件的使用、聚合和继承、依赖冲突的管理、项目打包发布、版本管理。在项目生命周期的基础上，分阶段进行管理，衍生出相应的小的工具，每一个小工具都成长为今天的mvn命令。项目打包方式有jar,war,pom形式，对于聚合和继承的父包，只能打包成pom的形式。<br>jar的版本管理主要是使用坐标定位groupid,artifactid,version;scope;等参数的使用。深入学习可以用《maven实战》。maven的实际使用也逐渐明白了，理论和实际能有一点互补，依赖的jar有就近原则（依赖路径最短），这个主要是maven的聚合和继承，这部分内容非常重要，也非常有用。</p>
</li>
<li><p>redis<br>　　redis是一种内存型数据库，相比于memcache，redis可以做到宕机不丢失数据，主要得益于他的save备份，redis对于开发者来说，可以作为缓存也可以当做数据库，无论当做什么，都摆脱不了它基于5大对象和基本数据结构的存储规则。redis基本不需要什么优化，如果说需要的话那只是在使用的层面上进行优化，什么样的数据选择什么样的对象，什么样的数据选择什么样的生存时间，什么样的数据适合使用内存，使用内存的效率是否得到提高?当用缓存的时候，命中率是否达到最大？都是在使用层面。所以实战才能出经验，不能滥用内存，毕竟内存宝贵。深入学习可以用《Redis实战》。在项目中主要是用Spring-data-redis管理，使用jedis进行池化，在代码中主要是用RedisTemplate进行操作。</p>
</li>
<li><p>Hibernate-Validator<br>　　validator校验器接触以后感觉真的很强大，校验字段，集合，以及参数，甚至集合中对象的字段也可以校验。对于hibernate-validator的原理，目前来看应该是使用拦截器技术，请求数据的校验发生在requestmapping之前。本身提供的基础数据类型校验也基本能够满足项目需要。  </p>
</li>
<li><p>properties文件配置<br>　　这一个根据向先文哥请教，理解了一些实现原理，通过这个跟体现出多问为什么的重要性，有些东西虽然我自己也有想法和认识，但是局限于自己的经验，并不会理解很深，有时候简单的做法，虽然一看就知道，但是要说出为什么这样用，好处都是什么，却是比较难的。</p>
</li>
<li><p>项目结构<br>　　一个月时间基本熟悉了各个包，知道了怎么下手，在仁坤哥的协助下做了一个krlass后端，短邮平台也了解挺多，目前来看，参与平台重构的话，在RabbitMQ上还不太会，不过通过参与模块划分和构建，对于架构设计也是有点兴趣。虽然如此，依旧任务挺重，不会的还是蛮多的，细节性东西需要学的太多，而这些东西又都是潜移默化的作用，所以用笔记本记录下来，没事多翻翻。这一个月没遇到什么bug，主要是项目构建和工具使用问题比较多，所以还需要继续努力。</p>
</li>
</ul>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>　　代码规范和文档规范是一个开发者的素质体现，进入公司以后，本着彻底放弃已有的模式学习。想迅速强大的快捷途径就是“复制”他们的代码、习惯、规范；融入自己，加以改进。<br>　　代码方面：单一职责，MVC分离，代码自注释，驼峰命名，CRUD命名，method.type严格匹配，数据库表和字段设计要保证当前项目可用，以后可扩展的方式，避免过度考虑表设计，需求理解以后前后端先对接碰头，避免在有多种选择的情况下，造成耗时（选择多了各种问题就来了……）；<br>　　文档方面：每个接口命名和注释，解决的问题，使用方式，使用场景，请求参数，响应结果都要说明。</p>
<h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><p>　　团队非常nice，整个融资线、Java组成员都非常给力，团结向上，积极努力，能学到很多东西，也能和大家一起成长，这点是非常重要的，反正我是超级喜欢。这一个月认识了Java组成员，业务线成员，当然还有两位技术VP，其他的虽然总是见面，不过没怎么认识，还有两个月，会认识更多人的。</p>
<p>-&gt;最后的话，还是要继续努力了，时间还有两个月了&lt;-</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一个小模块开发总结]]></title>
      <url>http://blog.zhangweiheu.cn/2015/11/12/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>　　这是在第一个小模块，开始提测的时候的总结。  </p>
<h3 id="代码的问题"><a href="#代码的问题" class="headerlink" title="代码的问题"></a>代码的问题</h3><ol>
<li>全力避免嵌套循环<br>　hashmap解决；</li>
<li>数据库字段设计必须考虑周全<br>　字段设计做到没有浪费和最大限度的复用；</li>
<li>接口规范一定要严格要求，代码有不规范的地方立即整改，不能因为用一次就松懈<br>　　接口规范按照开发规范来，接口设计和命名都要做到自解释；<br>　　DAO层要职责唯一,尽量可以最大化复用，合理利用重载；<br>　　Service层要承前启后，封装DAO；<br>　　Controller层做到接口即注释、数据的交互、URL必须明确、POST增/DELETE删/PUT改/GET查、封装数据；  </li>
<li>需求文档要深入解析，不可漏掉细节，必须详细记录细节性需求，合理拆分功能性接口  </li>
<li>不会或者不确定或者有思路的接口设计，都要征求高级工程师的意见，最好是先写一份初稿  </li>
</ol>
<h3 id="生活问题"><a href="#生活问题" class="headerlink" title="生活问题"></a>生活问题</h3><ol>
<li>合理安排时间，多学习  </li>
<li>住宿的地方最好选择离公司近的地方，多花钱是为了学习  </li>
<li>不懂得问题，最好自己在心里能实现，但是不要写出来，征求高级工程师的看法，进行改造  </li>
</ol>
<p>待周六更新……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实习开始]]></title>
      <url>http://blog.zhangweiheu.cn/2015/11/05/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>　　谨以此文纪念实习开端.</p>
<h4 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h4><p>　　这是一个积极的团队,大家彼此相互尊重,相互信任,相互配合,相互理解,高效的完成开发工作.每周例会实质上就是大家拿出自己的看法和意见,没有保留,这是一种非常好的氛围和状态,技术VP和我们一同参加例会,其实不知道他的身份,就能看出他的气场和能力都是非常强的.两个技术VP这两天算是都见过了,也都相互认识了. </p>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>　　今天也算是领到了一个任务,任务不大,但是依旧具有挑战性,因为在这么短的时间内熟悉框架和项目结构也是蛮拼的,不过我非常喜欢这种挑战.<br>　　整个Java开发组的同事都非常nice,大家都很忙,如果我有问题,他们依旧放下手中的活给我答疑解惑.对于开发人员来说这种中断是大忌,真的非常感谢大家无保留的教导.  </p>
<h4 id="实习目标"><a href="#实习目标" class="headerlink" title="实习目标"></a>实习目标</h4><p>　　实习的主要目的无非就是双向选择,无论双方是否能达成一致,我感觉这段实习经历都是非常美好的.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim快捷键]]></title>
      <url>http://blog.zhangweiheu.cn/2015/11/02/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p>　　宇宙中最强大的编辑器之一,程序猿必备操作.</p>
<h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul>
<li>:e filename　　打开文件编辑  </li>
<li>:w　　保存文件  </li>
<li>:q　　退出编辑器  </li>
<li>:q!　　退出但不保存</li>
<li>:x　　Write file (if changes has been made) and exit</li>
<li>.　　Repeats the last change made in normal mode</li>
<li>5.　　Repeats 5 times the last change made in normal mode</li>
<li>:sav filename　　Saves file as filename </li>
</ul>
<h4 id="剪切、复制和粘贴"><a href="#剪切、复制和粘贴" class="headerlink" title="剪切、复制和粘贴"></a>剪切、复制和粘贴</h4><ul>
<li>y　　Copy the selected text to clipboard</li>
<li>p　　Paste clipboard contents</li>
<li>dd　　Cut current line</li>
<li>yy　　Copy current line</li>
<li>y$　　Copy to end of line</li>
<li>D　　Cut to end of line</li>
</ul>
<h4 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a>在文件中移动</h4><ul>
<li>k or Up Arrow　　move the cursor up one line</li>
<li>j or Down Arrow　　move the cursor down one line</li>
<li>e　　move the cursor to the end of the word</li>
<li>b　　move the cursor to the begining of the word</li>
<li>0　　move the cursor to the begining of the line</li>
<li>G　　move the cursor to the end of the line</li>
<li>gg　　move the cursor to the begining of the file</li>
<li>L　　move the cursor to the end of the file</li>
<li>:59　　move cursor to line 59. Replace 59 by the desired line number.</li>
<li>20|　　move cursor to column 20.</li>
<li>%　　Move cursor to matching parenthesis</li>
<li>[[　　Jump to function start</li>
<li>[{　　Jump to block start</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul>
<li>/word　　Search word from top to bottom</li>
<li>?word　　Search word from bottom to top</li>
<li>*　　Search the word under cursor</li>
<li>/\cstring　　Search STRING or string, case insensitive</li>
<li>/jo[ha]n　　Search john or joan</li>
<li>/\&lt; the　　Search the, theatre or then</li>
<li>/the>　　Search the or breathe</li>
<li>/\&lt; the>　　Search the</li>
<li>/\&lt; ¦.>　　Search all words of 4 letters</li>
<li>/\/　　Search fred but not alfred or frederick</li>
<li>/fred|joe　　Search fred or joe</li>
<li>/\&lt;\d\d\d\d>　　Search exactly 4 digits</li>
<li>/^\n{3}　　Find 3 empty lines</li>
<li>:bufdo /searchstr/　　Search in all open files</li>
<li>bufdo %s/something/somethingelse/g　　Search something in all the open buffers and replace it with somethingelse</li>
</ul>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul>
<li>:%s/old/new/g　　Replace all occurences of old by new in file</li>
<li>:%s/onward/forward/gi　　Replace onward by forward, case unsensitive</li>
<li>:%s/old/new/gc　　Replace all occurences with confirmation</li>
<li>:2,35s/old/new/g　　Replace all occurences between lines 2 and 35</li>
<li>:5,$s/old/new/g　　Replace all occurences from line 5 to EOF</li>
<li>:%s/^/hello/g　　Replace the begining of each line by hello</li>
<li>:%s/$/Harry/g　　Replace the end of each line by Harry</li>
<li>:%s/onward/forward/gi　　Replace onward by forward, case unsensitive</li>
<li>:%s/*$//g　　Delete all white spaces</li>
<li>:g/string/d　　Delete all lines containing string</li>
<li>:v/string/d　　Delete all lines containing which didn’t contain string</li>
<li>:s/Bill/Steve/　　Replace the first occurence of Bill by Steve in current line</li>
<li>:s/Bill/Steve/g　　Replace Bill by Steve in current line</li>
<li>:%s/Bill/Steve/g　　Replace Bill by Steve in all the file</li>
<li>:%s/^M//g　　Delete DOS carriage returns (^M)</li>
<li>:%s/\r/\r/g　　Transform DOS carriage returns in returns</li>
<li>:%s#&lt;[^&gt;]+&gt;##g　　Delete HTML tags but keeps text</li>
<li>:%s/^(.*)\n\1$/\1/　　Delete lines which appears twice</li>
<li>Ctrl+a　　Increment number under the cursor</li>
<li>Ctrl+x　　Decrement number under cursor</li>
<li>ggVGg?　　Change text to Rot13</li>
</ul>
<h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><ul>
<li>Vu　　Lowercase line</li>
<li>VU　　Uppercase line</li>
<li>g~~　　Invert case</li>
<li>vEU　　Switch word to uppercase</li>
<li>vE~　　Modify word case</li>
<li>ggguG　　Set all text to lowercase</li>
<li>gggUG　　Set all text to uppercase</li>
<li>:set ignorecase　　Ignore case in searches</li>
<li>:set smartcase　　Ignore case in searches excepted if an uppercase letter is used</li>
<li>:%s/\&lt;./\u&amp;/g　　Sets first letter of each word to uppercase</li>
<li>:%s/\&lt;./\l&amp;/g　　Sets first letter of each word to lowercase</li>
<li>:%s/.*/\u&amp;　　Sets first letter of each line to uppercase</li>
<li>:%s/.*/\l&amp;　　Sets first letter of each line to lowercase</li>
</ul>
<h4 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h4><ul>
<li>:1,10 w outfile　　Saves lines 1 to 10 in outfile</li>
<li>:1,10 w &gt;&gt; outfile　　Appends lines 1 to 10 to outfile</li>
<li>:r infile　　Insert the content of infile</li>
<li>:23r infile　　Insert the content of infile under line 23</li>
</ul>
<h4 id="文件浏览器"><a href="#文件浏览器" class="headerlink" title="文件浏览器"></a>文件浏览器</h4><ul>
<li>:e.　　Open integrated file explorer</li>
<li>:Sex　　Split window and open integrated file explorer</li>
<li>:Sex!　　Same as :Sex but split window vertically</li>
<li>:browse e　　Graphical file explorer</li>
<li>:ls　　List buffers</li>
<li>:cd ..　　Move to parent directory</li>
<li>:args　　List files</li>
<li>:args *.php　　Open file list</li>
<li>:grep expression *.php　　Returns a list of .php files contening expression</li>
<li>gf　　Open file name under cursor</li>
</ul>
<h4 id="和-Unix-系统交互"><a href="#和-Unix-系统交互" class="headerlink" title="和 Unix 系统交互"></a>和 Unix 系统交互</h4><ul>
<li>:!pwd　　Execute the pwd unix command, then returns to Vi</li>
<li>!!pwd　　Execute the pwd unix command and insert output in file</li>
<li>:sh　　Temporary returns to Unix</li>
<li>$exit　　Retourns to Vi</li>
</ul>
<h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><ul>
<li>:%!fmt　　Align all lines</li>
<li>!}fmt　　Align all lines at the current position</li>
<li>5!!fmt　　Align the next 5 lines</li>
</ul>
<h4 id="Tabs-Windows"><a href="#Tabs-Windows" class="headerlink" title="Tabs/Windows　"></a>Tabs/Windows　</h4><ul>
<li>:tabnew　　Creates a new tab</li>
<li>gt　　Show next tab</li>
<li>:tabfirst　　Show first tab</li>
<li>:tablast　　Show last tab</li>
<li>:tabm n(position)　　Rearrange tabs</li>
<li>:tabdo %s/foo/bar/g　　Execute a command in all tabs</li>
<li>:tab ball　　Puts all open files in tabs</li>
<li>:new abc.txt　　Edit abc.txt in new window</li>
</ul>
<h4 id="分屏显示"><a href="#分屏显示" class="headerlink" title="分屏显示"></a>分屏显示</h4><ul>
<li>:e filename　　Edit filename in current window</li>
<li>:split filename　　Split the window and open filename</li>
<li>ctrl-w up arrow　　Puts cursor in top window</li>
<li>ctrl-w ctrl-w　　Puts cursor in next window</li>
<li>ctrl-w_　　Maximize current window vertically</li>
<li>ctrl-w|　　Maximize current window horizontally</li>
<li>ctrl-w=　　Gives the same size to all windows</li>
<li>10 ctrl-w+　　Add 10 lines to current window</li>
<li>:vsplit file　　Split window vertically</li>
<li>:sview file　　Same as :split in readonly mode</li>
<li>:hide　　Close current window</li>
<li>:­nly　　Close all windows, excepted current</li>
<li>:b 2　　Open #2 in this window</li>
</ul>
<h4 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h4><ul>
<li>Ctrl+n Ctrl+p (in insert mode)　　Complete word</li>
<li>Ctrl+x Ctrl+l　　Complete line</li>
<li>:set dictionary=dict　　Define dict as a dictionnary</li>
<li>Ctrl+x Ctrl+k　　Complete with dictionnary</li>
</ul>
<h4 id="Marks"><a href="#Marks" class="headerlink" title="Marks"></a>Marks</h4><ul>
<li>m{a-z} 　　Marks current position as {a-z}</li>
<li>‘{a-z}　　Move to position {a-z}</li>
<li>‘’　　Move to previous position</li>
</ul>
<h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><ul>
<li>:ab mail mail@provider.org　　Define mail as abbreviation of mail@provider.org</li>
</ul>
<h4 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h4><ul>
<li>:set autoindent　　Turn on auto-indent</li>
<li>:set smartindent　　Turn on intelligent auto-indent</li>
<li>:set shiftwidth=4　　Defines 4 spaces as indent size</li>
<li>ctrl-t, ctrl-d　　Indent/un-indent in insert mode  </li>
<li>‘&gt;&gt;　　Indent</li>
<li>&lt;&lt;　　Un-indent</li>
<li>=%　　Indent the code between parenthesis</li>
<li>1GVG=　　Indent the whole file</li>
</ul>
<h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><ul>
<li>:syntax o　　Turn on syntax highlighting</li>
<li>:syntax off　　Turn off syntax highlighting</li>
<li>:set syntax=perl　　Force syntax highlighting</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初遇北京]]></title>
      <url>http://blog.zhangweiheu.cn/2015/11/01/%E5%88%9D%E9%81%87%E5%8C%97%E4%BA%AC/</url>
      <content type="html"><![CDATA[<p>　　本篇文章是我在找到工作以后,来北京实习的第一篇文章,从哈尔滨出发,到今天刚好三天……</p>
<h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>　　第一天没有那么多的感受,有的只是对北京的渴望和新奇,感觉在北京的生活应该没有别人说的那么艰难,至少在我这个刚踏入社会，还没有一点经验的小本科生来说是的,我不相信那些鸡汤,也不相信那些因为自己的失败而埋怨北京的残酷的自述,我相信的只有我自己经历过的.  (对于这个相不相信的问题来说,我认为别人的经历可以听听,可以借鉴,但是不可以不辨别的效仿.一直以来我都遇到很多帮助过我的人,无论是在哪个方面,无论他们是否在我的生活中淡出,我都感谢他们,因为他们让我认为这个世界值得被温柔相待.我也一直是这样做的,我不会去想社会的现实会把我磨成什么样,但是我一直都努力成为一个真实的我.) 从北京站下车以后,一个人拖着行李箱,背着包,拎着电脑,如果说没有我的学长,我都不知道应该怎么办,本来打算住连锁酒店,不过确实是贵啊,两晚都要600大洋了,只能去我学长那凑合一晚.因为他周五加班,在等他的三个小时里面我真是感觉,如果没有朋友,我这样贸然前来或许真的就露宿街头了(夸张了一点).我学长也没有责任和义务帮我,虽然我在北京也认识的有两个高我一届的学长,也曾经一块吃饭喝酒,但是依旧不如我实验室的研究生学长,虽然我俩认识也就一年时间.总之认识的人终究只是认识的人,困难的时候还是真正的那几个人真心帮你.</p>
<h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>　　鉴于时间因素,下周一入职,只能用一天时间找房子,之前一天晚上赶紧用自如和丁丁约看房,当天晚上自如的管家就加我微信,约看房时间,还是个妹子,聊了一下租金的问题,本来我是大概租三个月,因为我还有点小算盘嘛,不过由于不容易租还没时间,所以只能狠心直接用自如了,一天下来累个半死,关键是我还背着书包和电脑,虽然累个半死,好在找到房子了,不然真的就废了,我学长也不会帮我了,本来把他也累得够呛。这一天发生了好多事,管家妹子给我钥匙以后,我直接习惯性拿一套留一套,结果那两把房门钥匙,有一把是新的,另外一把是旧的,结果我就拿了旧的,最后还是找合租的另外一位姐姐拿的钥匙,还打扰了那位姐姐看电影(其实拿钥匙的路上也是有故事的,和那位姐姐约定我到影院门口给她,结果手机到二楼的时候没电了,电影院在三楼,又下楼找管家妹子用她的手机.).回到屋中以后大门开了,房门钥匙又放在了管家妹子那里,又跑回去取的钥匙.然后又和学长去他那里拿东西.夜里9点多才睡.</p>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>　　今天还好,无非就是办理招商银行卡的时候等了三个小时,完事以后用百度地图导航,还没找到公交,放弃公交,先走其他路了,结果手机没电了,没办法只能随机走了,走了好久还是没辙,就坐了公交,坐了一圈又转回来,还好到了熟悉的地铁站,然后顺利返航,还顺便测试了另外一条回路,结果并不像想象中的那样近.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java五大原则]]></title>
      <url>http://blog.zhangweiheu.cn/2015/10/13/Java%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>本篇文章是对秦小波编写的<a href="http://baike.baidu.com/view/3308505.htm" target="_blank" rel="external">《设计模式之禅》(第二版)</a>的部分内容的学习总结，如有不足之处欢迎指正。</p>
<h3 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h3><h4 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h4><p>  一个类或者接口最多只有一个原因引起变化.<br>  单一职责提出了一个编写程序的标准，用“职责”或者“变化原因”来衡量接口或者类设计的是否优良，但是“职责”和“变化原因”都是不可衡量的,因项目而异，因环境而异.  </p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ol>
<li>类的复杂性降低,实现什么职责都有清晰明确的定义;   </li>
<li>可读性提高，复杂性降低;  </li>
<li>可维护性提高，可读性提高;   </li>
<li>变更引起的风险降低;<br>注：接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化</li>
</ol>
<h3 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h3><h4 id="四层概念解释"><a href="#四层概念解释" class="headerlink" title="四层概念解释:"></a>四层概念解释:</h4><ol>
<li>子类必须完全实现父类的方法;   </li>
<li>子类可以有自己的个性;   </li>
<li>覆盖或者实现父类的方法时输入参数可以被放大;<br>子类方法中的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松   </li>
<li>覆写或者实现父类的方法时输出结果可以被缩小;<br>注:父类出现的地方子类一定可以出现，反之不一定</li>
</ol>
<h3 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h3><h4 id="三层概念解释"><a href="#三层概念解释" class="headerlink" title="三层概念解释:"></a>三层概念解释:</h4><ol>
<li>高层模块不应该依赖底层模块，都应该依赖其抽象;</li>
<li>抽象模块不应该依赖细节;</li>
<li>细节应该依赖抽象;<br>注：抽象就是指接口或者抽象类，细节就实现类<br>依赖倒置原则在Java语言中的精简定义就是面向接口编程.</li>
</ol>
<h4 id="依赖的三种写法："><a href="#依赖的三种写法：" class="headerlink" title="依赖的三种写法："></a>依赖的三种写法：</h4><ol>
<li>构造函数传递依赖对象;</li>
<li>Setter方法传递依赖对象;</li>
<li>接口声明依赖对象(也叫接口注入);</li>
</ol>
<h4 id="对倒置的解释"><a href="#对倒置的解释" class="headerlink" title="对倒置的解释"></a>对倒置的解释</h4><p>依赖正置：就是类间的依赖是实实在在的的实现类间的依赖，也就是面向实现编程。而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中事物的依赖，“倒置”就是从这里产生.</p>
<h4 id="最佳实践原则："><a href="#最佳实践原则：" class="headerlink" title="最佳实践原则："></a>最佳实践原则：</h4><ol>
<li>每个类尽量都有接口或者抽象类，或者抽象类和接口两者兼备;</li>
<li>变量的表面类型尽量是接口或者抽象类;</li>
<li>任何类都不应该从具体类派生;</li>
<li>尽量不要覆写基类的方法;</li>
<li>结合里氏替换原则使用;</li>
</ol>
<h3 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h3><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><ol>
<li>实例接口(Object Interface),在Java中声明一个类，然后new关键字产生一个实例，这个类称为实例接口.</li>
<li>类接口(Class Interface),Java中进经常使用Interface关键字定义的接口.</li>
</ol>
<h4 id="隔离定义"><a href="#隔离定义" class="headerlink" title="隔离定义"></a>隔离定义</h4><ol>
<li>客户端不应该依赖它不需要的接口;</li>
<li>类间的依赖应该建立在最小接口上;</li>
</ol>
<h4 id="约束规范"><a href="#约束规范" class="headerlink" title="约束规范"></a>约束规范</h4><ol>
<li>接口尽量小(方法少，接口隔离原则拆分接口时，首先必须满足单一职责原则);</li>
<li>接口要高内聚;</li>
<li>定制服务(单独为个体提供定制接口);</li>
</ol>
<h4 id="实践规则"><a href="#实践规则" class="headerlink" title="实践规则"></a>实践规则</h4><ol>
<li>一个接口只服务于一个子模块或者业务逻辑;</li>
<li>已经被污染的接口，尽量去修改，若变更的风险大，则采用适配器模式进行转化处理;</li>
<li>了解环境，拒绝盲目依赖原则;</li>
</ol>
<h3 id="迪米特法则（Law-of-Demeter）"><a href="#迪米特法则（Law-of-Demeter）" class="headerlink" title="迪米特法则（Law of Demeter）"></a>迪米特法则（Law of Demeter）</h3><h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高.</p>
<h3 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h3><h4 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h4><p>一个软件实体如类、模块和函数都应该对修改关闭，对扩展开放</p>
<h4 id="开闭原则的意义"><a href="#开闭原则的意义" class="headerlink" title="开闭原则的意义"></a>开闭原则的意义</h4><p>只要是面向对象编程，在开发中都会用到开闭原则，开闭原则是以上五个原则的具体形态，是其精髓.</p>
<p><a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/cn/88x31.png"></a><br>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议</a>进行许可。</p>
]]></content>
    </entry>
    
  
  
</search>
